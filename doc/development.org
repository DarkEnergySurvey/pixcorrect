# -*- org-html-link-up: "http://decam03.fnal.gov:8080/notes/neilsen/";  org-html-link-home: "http://home.fnal.gov/~neilsen" -*-
#+TITLE:     pixcorrect development
#+AUTHOR:    Eric H. Neilsen, Jr.
#+EMAIL:     neilsen@fnal.gov
#+LANGUAGE:  en
#+OPTIONS:   H:3 num:3 ^:nil _:nil toc:nil ltoc:nil \n:nil @:t ::t |:t ^:t *:t TeX:t LaTeX:t
#+INFOJS_OPT: view:showall tdepth:1 toc:t ltoc:t mouse:underline path:http://home.fnal.gov/~neilsen/notebook/org-mode/org-info.js
#+LaTeX_CLASS: articleap
#+LaTeX_HEADER: \usepackage[section]{placeins}
#+LaTeX_HEADER: \usepackage{alltt}
#+LaTeX_HEADER: \usepackage{color}
#+LaTeX_HEADER: \definecolor{intrlred}{RGB}{169,58,63}
#+LaTeX_HEADER: \definecolor{aqua}{RGB}{65,155,133}
#+LaTeX_HEADER: \definecolor{prgold}{RGB}{210,140,0}
#+LaTeX_HEADER: \definecolor{nalblue}{RGB}{0,51,153}
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_HOME: http://home.fnal.gov/~neilsen
#+LINK_UP: http://home.fnal.gov/~neilsen/notebook
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/notebook.css" />
#+STARTUP: showall

* Initial state

** =imsupport=

The =imsupport= product contains C code for loading, saving, and
otherwise working with DES images. Particularly significant contents
of this product are:

 - mask bit definitions :: are defined in C pre-processor directives,
      duplicated in =include/imutils.h= and
      =include/imsupport.h=. There are separates sets of bits for use
      in the initial BPM and the mask HDUs of DES images.
 - =desimage= struct :: =include/imreadsubs.h= contains the =desimage=
      C struct, which includes elements for metadata corresponding to
      some FITS keywords, and pointers to arrays containing science
      data, weight, and mask pixel data.

** =imcorrect=

The =imcorrect= C code does the actual pixel-level correction on DES
images. For each operation, there appears to be a central bit of code
that actually does the calculation on each pixels. Sometimes these are
combined in the same loop over pixels, sometimes a calculation is
contained in its own loop.

** =fitsio=

=fitsio= is a python wrapper around the =CFITSIO= library, and
can be used to manipulate headers, and load and save pixel data as
=numpy= arrays.

** =ctypes=

=ctypes= is a base python method of calling C libraries. C manitulates
memory at a lower level than is typical for python program, and
=ctypes= includes tools for generating and interpreting arbitrary C
structures, mapping them to python objects.

Using =ctypes= with =numpy= can be slightly tricky. Internally,
=numpy= can store data in a variety of ways (row-major or column major
ordering of array elemets, big-endian or little-endian, and the
assorted combinations thereof). When =numpy= is used intirely within
python, the way in which the data is stored is invisible to the user:
the =numpy= code keeps track and does whatever is appropriate.

When one needs to pass a pointer to arrays of pixels to C code,
however, one needs to be sure that =numpy= is storing the pixels in
the order, type, and endian-ness expected by the C library. =numpy=
includes tools for supporting this.

* Progress

** =despyfits=

=despyfits= contains code for manipulating DES images from python
libraries, roughly analogous to =imsupport=. 

=despyfits= includes a header file, with lines cut-and-pasted from
=imsupport='s =include/imsupport.h=, that define bits in pixel
masks. There is also a trivial C library that imports these and
assigns the values to C extern variables, and a python module that
uses =ctypes= to provide access to these values from python. So, for
example, the =BADPIX_SATURATE= bit can be printed from python thus:

#+BEGIN_SRC python
Python 2.7.6 (default, Nov 10 2014, 12:26:08) 
[GCC 4.4.7 20120313 (Red Hat 4.4.7-3)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> from despyfits import maskbits
>>> 
>>> print maskbits.BADPIX_SATURATE
2
>>> 
#+END_SRC


To make sure there is only one cannonical definition of mask bits,
=imsupport='s =imutils.h= and =imsupport.h= now need to be modified to
include the file from =despyfits= rather than their own
definitions. Who owns =imsupport=?

=despyfits= includes a =DESImage= class for holding data associated
with a DES image, roughly analogous to the =desimage= C
struct. 

Because the code that does the calculations in =imcorrect= makes heavy
use of =imsupport='s =desimage= struct, and we would like to
cut-and-paste this code into C libraries to be called by python
through =ctypes=, =DESImage= includes a method that returns a
=ctypes.Structure= object that supplies a subset of the elements
defined in =imsupport='s =desimage= struct, and a C header file that
declares a C structure that corresponds to the structure generated by
=DESImage=. When the =DESImage= class is used to create this
=ctypes.Structure=, it automatically ensures that the numpy arrays are
stored in the right endianness and memory layout for use in C
code. If data in numpy arrays are passed to C code by some other
mechanism, this needs to be done in the new code, because numpy does
not guarantee the memory layout or endianness by default.

** =pixcorrect=

The development of the python utility that replicates =imcorrect= is
in progress.

It will include C libraries that replicate operations performed
by =imcorrect=, with C code copied directly from =imcorrect=. There
will be python modules that correspond to each operation, each of
which can be loaded independenly in python or executed independently
from a shell. In addition, there is a high-level driver that loads
each, and executes each in the proper order, loading and saving files
to disk only as necessary.

#+begin_src plantuml :file class_diagram.png
skinparam monochrome true
hide empty members
hide circle

PixCorrectImDriver <|-- PixCorrectImStep

class PixCorrectImDriver {
  {abstract} {static} run(ConfigParser)
  {static} add_step_args(ConfigParser)
  {static} parser()
  {static} config()
  {static} main()
}

note top of PixCorrectImDriver
 Code common to all commands executable 
 from the command line, including argument
 and configuration parsing and logging 
 initialization.
end note

class PixCorrectImStep {
  {abstract} {static} __call__(DESImage)
  {static} step_run(DESImage, ConfigParser)
  {static} run(ConfigParser)
} 

note top of PixCorrectImStep
 Code common to commands that execute
 one step only. Loads images ahead of 
 execution, and saves afterwards.
end note

PixCorrectImStep <|-- ApplyBPM
libbpm -- ApplyBPM
class ApplyBPM {
  {static} __call__(DESImage, DESImage)
  {static} step_run(DESImage, ConfigParser)
  {static} add_step_arguments(ConfigParser) 
}
ApplyBPM -- apply_bpm


PixCorrectImStep <|-- MaskSaturation
libmasksatr -- MaskSaturation
class MaskSaturation {
  {static} __call__(DESImage, DESImage)
  {static} step_run(DESImage, ConfigParser)
  {static} add_step_arguments(ConfigParser) 
}
MaskSaturation -- mask_saturation


PixCorrectImDriver <|-- PixCorrectIm
ApplyBPM -- PixCorrectIm
MaskSaturation -- PixCorrectIm
class PixCorrectIm {
  __init__(ConfigParser)
  {static} -run(ConfigParser)
  -image_data(string)
  -__getattr_(string)
  -clean_im(string)
  __call__()
  add_step_args(ConfigParser)
}
PixCorrectIm -- pixcorrect_im

#+end_src

#+RESULTS:
[[file:class_diagram.png]]

* Instructions for adding steps from =imcorrect= to =pixcorrect=

** Find the code in =imcorrect= that does the pixel level calculation
** Verify and update =desimage= if neede
*** Check =desimage=
Check that all elements of =imsupport='s =desimage= structure used
in this code are present in =despyfits='s =desimage= (in
=include/desimage.h=). Hopefully, all elements needed by the
=imcorrect= code to be moved will already by present, in which case
you can skip to the next step.
*** Supplement =include/desimage.h= in =despyfits=.
If there are needed elements missing from  
=include/desimage.h= in =despyfits=, copy them from the declaration of
the =desimage= struct in =include/imreadsubs.h= in =imsupport=.
*** Supplement =DESImageCStruct= class in =python/despyfits/DESImage.py=
Add the missing elements to the =DESImageCStruct= class in
=python/despyfits/DESImage.py=. Be sure to both add the new
helement to the =_fields_= property and the code to set the values
in the class's =__init__= method.

The =_fields_= property must list the same elements in the same order
with types corresponding to the declarations in the C header. The
mapping between =ctypes= types and basic C types can be found [[https://docs.python.org/2/library/ctypes.html#fundamental-data-types][here]]. 

If pointers are needed, use =ctypes.POINTER=. If an array of values is
needed, the clearest way to handle it is probably by declaring a new
python class. For example, the =ampsecan= field in the =desimage=
structure is an array of four integers, so the the =DESImage= python
module declares the class =FourInts= thus:

#+BEGIN_SRC python
FourInts = ctypes.c_int * 4
#+END_SRC

and the =ampsecan= element of the =_fields_= property of the
=DESImageCStruct= class is declared to be of that type.

*** recompile =despyfits= using the =setup.py=

The C libraries used in =despyfits= depend on the =desimage.h= header,
and so must be recompiled to incorporate any changes. Because this is
a python pack, use python's =setuptools= to do this:

#+BEGIN_SRC sh
cd $DESPYFITS_DIR
python setup.py build
#+END_SRC

*** check the updated =depyfits= into =svn=, and =svn update= =pixcorrect=

The =desimage.h= header file appears in the =pixcorrect= product by
way on an =svn external= directory; to be seen by the =pixcorrect= C
code, it must be checked into =svn= from =despyfits=, and the =svn
update=d into your checked out =pixcorrect= product.

** Wrap C code from =imcorrect.c=
Copy the code in =imcorrect.c= to a C file in =pixcorrect='s =src=
directory, calling it =lib${STEPNAME}.c=. Make sure the loop over
pixels is included in the library; see =src/libbpm.c= or
=src/libmasksatr.c= for examples.

Be careful allocating and freeing memory within the C
library. Python's memory managemen and garbage collection knows
nothing about memory allocated or freed within the library, so if you
allocate code and do not free it, it will be a memory leak, and if you
free memory allocated by python (and seen by the C library through a
passed pointer), it will cause python to segfault.

** Add the new C library to =setup.py= in =pixcorrect=

The =setup.py= builds the libraries in the =pixcorrect= product. Two
changes are need for this. First, an object of class =SharedLibrary=
needs to be created with instructions for building the new
library. For example, the creation of the =SharedLibrary= object for
=libbpm= looks like this:

#+BEGIN_SRC python
libbpm = SharedLibrary(
    'bpm',
    sources = ['src/libbpm.c'],
    include_dirs = ['include'],
    extra_compile_args = ['-O3','-g','-Wall','-shared','-fPIC'])
#+END_SRC

Other libraries are likely to look very similar.

Then, this new object needs to be added to the list of shared
libraries that need to be built to build the product, specified in the
=shlibs= parameter in the =setup= call.

** Compile =pixcorrect=
Run =setup.py= in the root of =pixcorrect=:

#+BEGIN_SRC sh
cd ${PIXCORRECT_DIR}
python setup.py build
#+END_SRC

** Create a =python= module for the new step
The module should supply an API for calling the step programatically,
and also code for running it stand-alone. Use =apply_bpm.py= or
=mask_saturation.c= as a template. Test that the new python module
runs.
** Add the step to =pixcorrect_im.py=
This is the module that calls all steps in sequence. Test that
=pixcorrect_im= runs.
** Add a =doctest= or =unittest= 
These should verify that your new step does what you think it
does. (An example of this has not been completed yet.)



