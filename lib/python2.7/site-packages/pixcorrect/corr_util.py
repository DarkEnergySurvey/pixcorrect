"""Common for image correction steps"""

# imports
from functools import wraps
from ConfigParser import SafeConfigParser 
from argparse import ArgumentParser
import logging
from contextlib import closing
from os import path
import time

import pyfits
import numpy as np

from pixcorrect import proddir

# constants

logger = logging.getLogger('pixcorrect')

# exception classes

class ArrayShapeException(Exception):
    pass

# This exception to be thrown when a call to an external library
# returns a non-zero value, indicating an error of some sort
class LibraryException(Exception):
    def __init__(self, value):
        self.value = value

# interface functions

# A decorator that uses a FITS keyword to determine whether a step
# has already been performed, and skips it if it has.
def do_once(arg_idx, fits_keyword):
    def make_do_once_wrapper(f):
        @wraps(f)
        def f_wrapper(*args, **kwargs):
            hdu = args[arg_idx]
            if fits_keyword in hdu.header.keys():
                done = hdu.header[fits_keyword]
            else:
                done = False
            if not done:
                result = f(*args, **kwargs)
                hdu.header[fits_keyword]=time.asctime(time.localtime())
            else:
                logger.warning("Skipping " + f.__name__ +  " (already done)")
            return result
        return f_wrapper
    return make_do_once_wrapper

def read_im_hdu(config, section, fname_keyword, hdu_id_keyword=None):
    """Read a PyFITS ImageHDU from a source specified in a config file
    making sure the result is stored in memory with the proper
    native endianness.

    :Parameters:
        -`config`: the python ConfigParser from which to read the source
        -`section`: the section name in the config file in which to look
        -`fname_keyword`: the option in the config file with the file name
        -`hdu_id_keyword`: the option in the config file with the extension

    @returns: the PyFITS ImageHDU read
    """
    fname = config.get(section, fname_keyword)
    hdu_id = 0 if hdu_id_keyword is None \
             else config.getint(section, hdu_id_keyword)
    with closing( pyfits.open(fname) ) as hdulist:
        hdu = hdulist[hdu_id]
        
        # By default, pyfits seems to keep the data in FITS byte order.
        # We need it in native (N) byte order.
        native_dtype = hdu.data.dtype.newbyteorder('N')
        try:
            data = hdu.data.astype(native_dtype, casting='equiv', copy=False)
        except TypeError:
            # Older version of numpy
            data = hdu.data.astype(native_dtype)

        native_hdu = pyfits.ImageHDU(data, hdu.header)

        nx, ny = hdu.data.shape
        logger.info('read %d by %d image from hdu %d of %s',
                    nx, ny, hdu_id, fname)
    return native_hdu

def write_im_hdu(config, section, hdu, fname_keyword):
    """Write a PyFITS ImageHDU to a destination specified in a config file

    :Parameters:
        -`config`: the python ConfigParser from which to read the destination
        -`section`: the section name in the config file in which to look
        -`hdu`: the PyFITS ImageHDU to write to the file
        -`fname_keyword`: the option in the config file with the file name

    @returns: 0 if successful 
    """
    fname = config.get(section, fname_keyword)
    hdus=[pyfits.PrimaryHDU(hdu.data, hdu.header)]
    hdulist = pyfits.HDUList(hdus)
    hdulist.writeto(fname)
    return 0
    
class PrepMain(object):
    def __init__(self, step_name, description, switch_opts={}):
        default_config = path.join(proddir, 'etc', step_name+'.config')
        default_out_config = path.join(step_name+'-as_run'+'.config')

        # Parse arguments
        self.parser = ArgumentParser(description=description)
        self.parser.add_argument("config", default=default_config, nargs="?",
                            help="Configuration file filename")
        self.parser.add_argument('-s', '--saveconfig', 
                                 default=default_out_config,
                                 help="output config file")
        self.parser.add_argument('-l', '--log', 
                                 default=step_name+".log", 
                                 help="the name of the logfile")
        self.parser.add_argument('-v', '--verbose', action="count", 
                                 help="be verbose")
        self.parser.add_argument('-o', '--options', 
                                 default=[], nargs='*',
                            help="option to override parameters in the " + \
                            step_name + " section of the configuration file")
        self.parser.add_argument('-g', '--global_options', 
                                 default=[], nargs='*',
            help="option to override global section of the configuration file")

        self.switch_opts = switch_opts
        self.step_name = step_name

    def __call__(self):
        args = self.parser.parse_args()

        # start logger
        logging.basicConfig(filename=args.log,
                            format="%(asctime)s\t%(message)s",
                            level=logging.WARNING)
        global logger
        logger = logging.getLogger()
        if args.verbose > 0:
            verbosity = logging.INFO if args.verbose==1 else logging.DEBUG
            logger.setLevel(verbosity)

        logger.addHandler(logging.StreamHandler())

        # load configuration
        config = SafeConfigParser() 
        config.read(args.config) 

        kv_overrides = ( ('global', args.global_options),
                      (self.step_name, args.options) )
        for section, arguments in kv_overrides:
            if not config.has_section(section):
                config.add_section(section)
            for argument in arguments:
                kv_pair = argument.split('=')
                key = kv_pair[0]
                value = True if len(kv_pair)<2 else kv_pair[1]
                config.set(section, key, value)

        for section in self.switch_opts:
            if not config.has_section(section):
                config.add_section(section)
            for argument in self.switch_opts[section]:
                value = getattr(args, argument)
                if value is not None:
                    if type(value)==type([]):
                        value=value[0]
                    config.set(section, argument, str(value))
            
        with open(args.saveconfig, 'w') as out_config:
            config.write(out_config)

        return config
                     

def prep_main(description, step_name):
    pm = PrepMain(step_name, description)
    config = pm()
    return config

def old_prep_main(description, step_name):
    """Parse arguments, load configuration, and start logger

    @returns: a tuple with the parsed arguments, logger, and parsed config
    """

    default_config = path.join(proddir, 'etc', step_name+'.config')

    # Parse arguments
    parser = ArgumentParser(description=description)
    parser.add_argument("config", default=default_config, nargs="?",
                        help="Configuration file filename")
    parser.add_argument('-l', '--log', default=step_name+".log", 
                        help="the name of the logfile")
    parser.add_argument('-v', '--verbose', action="count", 
                        help="be verbose")
    parser.add_argument('-o', '--options', default=[], nargs='*',
                        help="option to override parameters in the " + \
                        step_name + " section of the configuration file")
    parser.add_argument('-g', '--global_options', default=[], nargs='*',
                        help="option to override global section of the configuration file")
    args = parser.parse_args()
    
    # start logger
    logging.basicConfig(filename=args.log,
                        format="%(asctime)s\t%(message)s",
                        level=logging.WARNING)
    global logger
    logger = logging.getLogger()
    if args.verbose > 0:
        verbosity = logging.DEBUG if args.verbose==1 else logging.DEBUG
        logger.setLevel(verbosity)

    logger.addHandler(logging.StreamHandler())

    # load configuration
    config = SafeConfigParser() 
    config.read(args.config) 

    overrides = ( ('global', args.global_options),
                  (step_name, args.options) )
    for section, arguments in overrides:
        if not config.has_section(section):
            config.add_section(section)
        for argument in arguments:
            kv_pair = argument.split('=')
            key = kv_pair[0]
            value = True if len(kv_pair)<2 else kv_pair[1]
            config.set(section, key, value)
        
    return config

# contract conditions

def match_array_shapes(arglist, func_args=None, func_kwargs=None, func_result=None):
    """A dbc contract condition that forces multiple arguments to be the same shape 

    A function suitable for passing as the first argument to the
    precondition, postcondition, or invariantcondition decorators in
    the dbc module.

    :Parameters:
        -`arglist`: a list of argument indexes to check

    Raises an ImageShapeException if all of the arguments in arglist are not
    numpy arrays with the same shape.

    """
    ref_shape = func_args[arglist[0]].shape
    for i in arglist[1:]:
        if func_args[arglist[i]].shape != ref_shape:
            raise ImageShapeException() 

def no_lib_error(func_args=None, func_kwargs=None, func_result=None):
    """A dbc contract condition that checks that the returned value is 0

    A function suitable for passing as the first argument to the
    precondition, postcondition, or invariantcondition decorators in
    the dbc module.

    Raises a LibraryException if the wrapped function returns a 
    non-zero value. This is useful when wrapping C libraries that
    follow the converntion that returning a non-zero value 
    indicates an error.
    """
    if func_result != 0:
        raise LibraryException() 

# classes
# internal functions & classes
