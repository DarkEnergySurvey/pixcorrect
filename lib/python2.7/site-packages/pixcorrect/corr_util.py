"""Common for image correction steps"""

# imports
from functools import wraps
from ConfigParser import SafeConfigParser 
from argparse import ArgumentParser
import logging
from contextlib import closing
from os import path

import pyfits
import numpy as np

from pixcorrect import proddir

# constants

logger = logging.getLogger()

# exception classes

class ArrayShapeException(Exception):
    pass

# This exception to be thrown when a call to an external library
# returns a non-zero value, indicating an error of some sort
class LibraryException(Exception):
    def __init__(self, value):
        self.value = value

# interface functions

def read_im_hdu(config, section, fname_keyword, hdu_id_keyword=None):
    """Read a PyFITS ImageHDU from a source specified in a config file
    making sure the result is stored in memory with the proper
    native endianness.

    :Parameters:
        -`config`: the python ConfigParser from which to read the source
        -`section`: the section name in the config file in which to look
        -`fname_keyword`: the option in the config file with the file name
        -`hdu_id_keyword`: the option in the config file with the extension

    @returns: the PyFITS ImageHDU read
    """
    fname = config.get(section, fname_keyword)
    hdu_id = 0 if hdu_id_keyword is None \
             else config.getint(section, hdu_id_keyword)
    with closing( pyfits.open(fname) ) as hdulist:
        hdu = hdulist[hdu_id]
        
        # By default, pyfits seems to keep the data in FITS byte order.
        # We need it in native (N) byte order.
        native_dtype = hdu.data.dtype.newbyteorder('N')
        try:
            data = hdu.data.astype(native_dtype, casting='equiv', copy=False)
        except TypeError:
            # Older version of numpy
            data = hdu.data.astype(native_dtype)

        native_hdu = pyfits.ImageHDU(data, hdu.header)

        nx, ny = hdu.data.shape
        logger.info('read %d by %d image from hdu %d of %s',
                    nx, ny, hdu_id, fname)
    return native_hdu

def write_im_hdu(config, section, hdu, fname_keyword):
    """Write a PyFITS ImageHDU to a destination specified in a config file

    :Parameters:
        -`config`: the python ConfigParser from which to read the destination
        -`section`: the section name in the config file in which to look
        -`hdu`: the PyFITS ImageHDU to write to the file
        -`fname_keyword`: the option in the config file with the file name

    @returns: 0 if successful 
    """
    fname = config.get(section, fname_keyword)
    hdus=[pyfits.PrimaryHDU(hdu.data, hdu.header)]
    hdulist = pyfits.HDUList(hdus)
    hdulist.writeto(fname)
    return 0
    
def prep_main(description, step_name):
    """Parse arguments, load configuration, and start logger

    @returns: a tuple with the parsed arguments, logger, and parsed config
    """

    default_config = path.join(proddir, 'etc', step_name+'.config')

    # Parse arguments
    parser = ArgumentParser(description=description)
    parser.add_argument("config", default=default_config, nargs="?",
                        help="Configuration file filename")
    parser.add_argument('-l', '--log', default=step_name+".log", 
                        help="the name of the logfile")
    parser.add_argument('-v', '--verbose', action="count", 
                        help="be verbose")
    parser.add_argument('-o', '--options', default=[], nargs='*',
                        help="option to override parameters in the " + \
                        step_name + " section of the configuration file")
    parser.add_argument('-g', '--global_options', default=[], nargs='*',
                        help="option to override global section of the configuration file")
    args = parser.parse_args()
    
    # start logger
    logging.basicConfig(filename=args.log,
                        format="%(asctime)s\t%(message)s",
                        level=logging.WARNING)
    global logger
    logger = logging.getLogger()
    if args.verbose > 0:
        verbosity = logging.INFO if args.verbose==1 else logging.DEBUG
        logger.setLevel(verbosity)

    logger.addHandler(logging.StreamHandler())

    # load configuration
    config = SafeConfigParser() 
    config.read(args.config) 

    overrides = ( ('global', args.global_options),
                  (step_name, args.options) )
    for section, arguments in overrides:
        if not config.has_section(section):
            config.add_section(section)
        for argument in arguments:
            kv_pair = argument.split('=')
            key = kv_pair[0]
            value = True if len(kv_pair)<2 else kv_pair[1]
            config.set(section, key, value)
        
    return config

# contract conditions

def match_array_shapes(arglist, func_args=None, func_kwargs=None, func_result=None):
    """A dbc contract condition that forces multiple arguments to be the same shape 

    A function suitable for passing as the first argument to the
    precondition, postcondition, or invariantcondition decorators in
    the dbc module.

    :Parameters:
        -`arglist`: a list of argument indexes to check

    Raises an ImageShapeException if all of the arguments in arglist are not
    numpy arrays with the same shape.

    """
    ref_shape = func_args[arglist[0]].shape
    for i in arglist[1:]:
        if func_args[arglist[i]].shape != ref_shape:
            raise ImageShapeException() 

def no_lib_error(func_args=None, func_kwargs=None, func_result=None):
    """A dbc contract condition that checks that the returned value is 0

    A function suitable for passing as the first argument to the
    precondition, postcondition, or invariantcondition decorators in
    the dbc module.

    Raises a LibraryException if the wrapped function returns a 
    non-zero value. This is useful when wrapping C libraries that
    follow the converntion that returning a non-zero value 
    indicates an error.
    """
    if func_result != 0:
        raise LibraryException() 

# classes
# internal functions & classes
