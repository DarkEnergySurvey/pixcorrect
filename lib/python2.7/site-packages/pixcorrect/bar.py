#!/usr/bin/env python
"""Example step in image correction"""

# imports
from functools import partial
import ctypes
import sys
from os import path

import numpy as np
import pyfits

from pixcorrect.dbc import precondition, postcondition
from pixcorrect import corr_util
from pixcorrect.corr_util import read_im_hdu, write_im_hdu
from pixcorrect.corr_util import prep_main, logger
from pixcorrect import imtypes
from pixcorrect import proddir

# constants

# Which section of the config file to read for this step
config_section = 'bar'

# exception classes
# interface functions

@precondition(imtypes.args_type1, 0)
@precondition(imtypes.args_type0, 1)
@postcondition(imtypes.args_type1, 0)
@postcondition(imtypes.args_type3, 1)
def bar(hdu1, hdu3, config):
    """Apply bar to hdu1 and overwrite hdu3 with the result.
    Reads the needed coefficient from a ConfigParser

    :Parameters:
        - `hdu1`: A PyFITS ImageHDU with the input
        - `hdu3`: A PyFITS ImageHDU to be overwritten with the result
        - `config`: A python ConfigParser object providing the coefficient

    """
    coeff = config.getfloat(config_section, 'coeff')
    array_bar(hdu1.data, hdu3.data, coeff)
    hdu3.header['BARCOEFF'] = coeff
    logger.info('Completed bar')

# classes
# internal functions & classes

# Lowest level access to the C library function
_array_bar_lib = np.ctypeslib.load_library('libbar.so',
                                           path.join(proddir, 'lib')) 
_array_bar = _array_bar_lib.bar
_array_bar.restype = ctypes.c_int
_array_bar.argtypes = [np.ctypeslib.ndpointer(ctypes.c_double, ndim=2,
                                              flags='aligned, contiguous'),
                       np.ctypeslib.ndpointer(ctypes.c_double, ndim=2,
                                              flags='aligned, contiguous, writeable'),
                       ctypes.c_double,
                       ctypes.c_int]

# Add a wrapper around the library interface to 
# check diminsions and verify the call returned okay.
@precondition(corr_util.match_array_shapes, (0,1))
@postcondition(corr_util.no_lib_error)
def array_bar(ar1, ar2, coeff):
    """Apply operation bar to numpy array ar1, writing the result to ar2
    
    :Parameters:
        -`ar1`: a numpy array
        -`ar2`: a numpy array
        -`coeff`: a coefficient

    @returns: 0 if successful, an error code otherwise
    """
    nelem = ar1.size
    result = _array_bar(ar1, ar2, coeff, nelem)
    return result

# The high level driver when run stand-alone
def bar_main(config):
    """A driver for applying operation bar

    :Parameters:
        -`config`: a python ConfigParsers object

    @returns: 0 if successful
    """

    # Load files and images here if we don't want
    # bar to clean up the memory, because other drivers that
    # call bar might want it for future steps.
    hdu1 = read_im_hdu(config, config_section, 'im1_fname', 'im1_hdu')
    
    hdu3 = pyfits.ImageHDU(np.empty_like(hdu1.data))

    bar(hdu1, hdu3, config)

    write_im_hdu(config, config_section, hdu3, 'out_fname')

    return 0

if __name__ == '__main__':
    config = prep_main("Do step bar", config_section)
    try:
        bar_main(config)
        sys.exit(0)
    except:
        # If we want to set specific exit status values
        # based on what exceptions get thrown, do that
        # here
        raise
