#!/usr/bin/env python
"""Example step foo in image correction"""

# imports
from functools import partial
import ctypes
import sys
from os import path

import numpy as np

from pixcorrect.dbc import precondition, postcondition
from pixcorrect import corr_util
from pixcorrect.corr_util import read_im_hdu, write_im_hdu
from pixcorrect.corr_util import prep_main, logger
from pixcorrect import imtypes
from pixcorrect import proddir

# constants

# Which section of the config file to read for this step
config_section = 'foo'

# exception classes
# interface functions

# The precondition and postcondition decorators use
# args_type1 (defined in imtypes) to 
# sanity check starting and resulting image for 
# correct FITS keywords and dimensions
#
@precondition(imtypes.args_type1, 0)
@postcondition(imtypes.args_type1, 0)
def foo(hdu1, config):
    """Apply operation foo to a provided PyFITS ImageHDU
    reading operand hdu2 from a FITS file

    :Parameters:
        - `hdu1`: A PyFITS ImageHDU with the data to which to apply foo
        - `config`: A python ConfigParser object from which the hdu2 is reade

    Applies operation foo "in place" to hdu1.
    """
    coeff = config.getfloat(config_section, 'coeff')
    
    # Load files and images here if they should be cleaned up 
    # here (should never be kept in memory for future steps).
    hdu2 = corr_util.read_im_hdu(config, config_section, 'im2_fname', 'im2_hdu')
    Type2ImageChecker.check(hdu2)
    array_foo(hdu1.data, hdu2.data, coeff)
    logger.info('Completed foo')

# classes
# internal functions & classes

# Lowest level access to the C library function
_array_foo_lib = np.ctypeslib.load_library('libfoo.so',
                                           path.join(proddir, 'lib')) 
_array_foo = _array_foo_lib.foo
_array_foo.restype = ctypes.c_int
_array_foo.argtypes = [np.ctypeslib.ndpointer(ctypes.c_double, ndim=2,
                                              flags='aligned, contiguous, writeable'),
                       np.ctypeslib.ndpointer(ctypes.c_double, ndim=2,
                                              flags='aligned, contiguous'),
                       ctypes.c_double,
                       ctypes.c_int]

# Add a wrapper around the library interface to 
# check diminsions and verify the call returned okay.
@precondition(corr_util.match_array_shapes, (0,1))
@postcondition(corr_util.no_lib_error)
def array_foo(ar1, ar2, coeff):
    """Apply operation foo to numpy arrays ar1 and ar2
    
    :Parameters:
        -`ar1`: a numpy array
        -`ar2`: a numpy array
        -`coeff`: a coefficient

    @returns: 0 if successful, an error code otherwise
    """
    nelem = ar1.size
    result = _array_foo(ar1, ar2, coeff, nelem)
    return result

# Image type checks specific to this module

# I put this check here and not in imtypes under the assumption that
# this image type only applies to this module. If this check will be 
# needed elsewhere, it should go in imtypes instead
class Type2ImageChecker(imtypes.Type0ImageChecker):
    kwdict = {'FORFOO': True,
              'BOGUS': 'nope'}

# The high level driver when run stand-alone

def foo_main(config):
    """A driver for applying operation foo

    :Parameters:
        -`config`: a python ConfigParsers object

    @returns: 0 if successful
    """
    # Load files and images here if we don't want
    # foo to clean up the memory, because other drivers that
    # call foo might want it for future steps.
    hdu1 = read_im_hdu(config, config_section, 'im1_fname', 'im1_hdu')

    foo(hdu1, config)

    write_im_hdu(config, config_section, hdu1, 'out_fname')

    return 0

if __name__ == '__main__':
    config = prep_main("Do step foo", config_section)
    try:
        foo_main(config)
        sys.exit(0)
    except:
        # If we want to set specific exit status values
        # based on what exceptions get thrown, do that
        # here
        raise
